1. Introduction
The aim of today's laboratory is to test the performance of the SQLite database compared to other methods of data storage in C programs. To accomplish this, you will prepare simple programs managing a large amount of data: using native data structures typical for the programming language and SQLite database.

To ensure comparable results, all exercises should be conducted in the same environment (e.g., on the same machine).

2. Useful Materials
An Introduction To The SQLite C/C++ Interface
C/C++ API Reference
GNU C Reference Manual
3. Tips
3.1. Compiling Programs Using GCC
To compile source code, simply run the gcc program, specifying the filename with the source code as an argument:

gcc my_program.c
— this will create a file named a.out in the current directory. You can then run it using the command:

./a.out
Using the -o switch, you can specify the name of the target file:

gcc my_program.c -o my_program
./my_program
To utilize the SQLite API, the program needs to be linked with the sqlite3 library using the -lsqlite3 switch:

gcc my_sqlite_program.c -o my_sqlite_program -lsqlite3
3.2. Measuring Resource Usage in ANSI C
Dynamic memory allocation:

data = malloc(sizeof(struct Rec) * MAX);
if (data == NULL) {
	fprintf(stderr, "Memory allocation error\n");
	return 1;
}
// ...
free(data);
Measuring time, see man 3 clock:

#include <time.h>
// ...
clock_t c1, c2;
// ...
c1 = clock();
// ...
c2 = clock();
// ...
printf("time, c2-c1[s]: %f\n", ((float)c2 - (float)c1) / CLOCKS_PER_SEC);
Memory usage in Linux system, see man 2 getrusage:

struct rusage mem;
// ...
getrusage(RUSAGE_SELF, &mem);
printf("Max memory usage[kB]: %ld\n", mem.ru_maxrss);
3.3. SQLite API
Opening a database "connection":

int rc;
sqlite3 *db;
char loc[] = ":memory:";
// ...
rc = sqlite3_open(loc, &db);
if (rc) {
	fprintf(stderr, "Can’t open database: %s\n", sqlite3_errmsg(db));
	return 1;
}
// ...
sqlite3_close(db);
The character string loc stores information about the database location – filename or :memory: for in-memory databases.

Executing queries is simplest using sqlite3_exec():

rc = sqlite3_exec(db,
	"CREATE TABLE inv (id integer PRIMARY KEY, name varchar(20), "
	"desc varchar(90));",
	NULL, NULL, NULL);
if (rc) {
	fprintf(stderr, "Database create table error: %s\n", sqlite3_errmsg(db));
	return 1;
}
If the query returns values, a callback function must be used, as shown in the lecture.

Prepared statements can also be used:

char *sql;
sqlite3_stmt *stmt;
// …
sql = "SELECT * FROM mytable";
rc = sqlite3_prepare_v2(db, sql, strlen(sql), &stmt, NULL);
if (rc) {
	fprintf(stderr, "Database prepare statement error: %s\n", sqlite3_errmsg(db));
	return 1;
}
do {
	rc = sqlite3_step(stmt);
	if (rc == SQLITE_ROW) {
		printf("I found something: %s, %s, %d\n", (char *)sqlite3_column_text(stmt, 0),
		(char *)sqlite3_column_text(stmt, 2));
		sqlite3_column_int(stmt, 1),
	}
} while (rc == SQLITE_ROW);
sqlite3_finalize(stmt);
Such a query can be reused multiple times using the sqlite3_reset() command:

sql = "INSERT INTO purchases VALUES (?1,?2)";
rc = sqlite3_prepare_v2(db, sql, strlen(sql), &stmt, NULL);
if (rc) {
	fprintf(stderr, "Database prepare statement error: %s\n", sqlite3_errmsg(db));
	return 1;
}
for (i = 0; i < MAX; i++) {
  sqlite3_bind_int(stmt, 1, how_many[i]); /* number of purchases */
  sqlite3_bind_text(stmt, 2, what[i], strlen(what[i]) + 1,
    SQLITE_STATIC); /* purchase name */
  rc = sqlite3_step(stmt);
  if (rc != SQLITE_DONE) {
    fprintf(stderr, "Database insert error\n");
  }
  sqlite3_reset(stmt);
}
sqlite3_finalize(stmt);
4. Exercises
In each exercise, measure:

memory usage,
time needed to generate records,
time taken to search for a record.
4.1. Exercise 1
Write a C program that dynamically allocates memory for a data structure containing the following attributes: id (integer), name (string, 20 characters), and description (string, 90 characters).

This can be done as follows:

struct Rec {
  int id; /* unique identifier, primary key */
  char name[20]; /* name */
  char desc[90]; /* description */
};
Fill the structure with sample data (the values do not matter, but id must be consecutive numbers starting from 0); generate 1,000,000 records.

Sequentially search for a record with an id equal to 999999.

Note: In shared environments, execution time may vary depending on the load generated by other users. Repeat each experiment several times for reliable measurements.

4.2. Exercise 2
Repeat exercise 1 using SQLite. Check different combinations of parameters:

data storage method – memory vs. file,
use of transactions – adding BEGIN and COMMIT before and after the command sequence,
use of indexes,
different journaling modes – by setting different values of the journal_mode parameter, especially DELETE (default) and WAL (write-ahead log).
5. Report
In the report, prepare a summary of results for different configurations and combinations of parameters, along with a brief comment on why a particular change has a specific impact on performance.
